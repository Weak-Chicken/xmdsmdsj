# Article Part

## Showing Articles on Our Page

---

### Goal

Now we have finished the very basic logging in system. Although there are still many bugs in there (For example, you have to re-login if refreshing the page.), I will leave it there and maybe working on that later. For now, our priority is to build our article displaying page.

In this part, our main job is to make basic article uploading, showing and deleting functions. It requires:

1. Logged in user can upload articles into their account. 
2. Logged in user can see all its articles in its account page. Logged in user can see a button on their account page to let them upload their articles.
3. When articles are uploaded, database will record its uploaded time, last modified time etc. Anyway, extra infomation will be recorded.
4. Uploaded articles will be shown in '/article/', no matter which user uploaded it. The title of it will be shown with a hyperlink to the details of this article.
5. Click on article page could get into the article, where you can read the article and see the details.

---

### Steps

1. Create fake data in frontend for articles.

> First, according to our working procedure, we need to first create our fake data in data provider for our frontend. Then, after well tested, write this fake data structure into our API document and implement it in our backend and database. Therefore, the fake data need to be considered seriously.
> 
> Inspired by [cnodejs topic API](https://cnodejs.org/api/v1/topics/?page=1&limit=10), I decide to define my fake data with these extra data. Here it contains only three articles as an example.
> 
> The fake data is in the form of:
> 
> ```json
> "success": true,
> "articles": [
>   {
>     "article_id": "testArticleId0",
>     "user_id": "testUserId0",
>     "title": "article0",
>     "created_at": "2019-05-02T04:32:09.537Z",
>     "last_modified_at": "2019-05-02T04:32:09.537Z",
>     "author": {
>       "userName": "Jon",
>     },
>     "content": "content_here",
>   },
> 
>   ...
> ]
> 
> ```
> 
> So 7 items are defined in this standard.
> 
> Now, the next step is to insert this fake data into our page. When changing my old code to be usable with new data provider, I realized an old problem I left here: How do I get arcitle details when I clicked on the title of one article in post page? Originally, I send html file as a parameter through router to new article page. However, this is clearly bad. First, it's not working when the user refreshing their page. Once the user refreshes an article page, this page will lost its html data.
> 
> So, there's only one solution to this: send another request to the backend to obtain the details of specific article. To do this, we'll need a new API to obtain articles by their Ids. Besides, since we don't need details when just posting them, we should remove 'content' from our posts API to increase its speed.
> 
> So now our article related APIs are changed to this:
> 
> ```js
> mountingPoint.getAllArticlesPosts = (succeeded) => {
>   if (succeeded) {
>     return {
>       "success": true,
>       "articles": [
>         {
>           "article_id": "testArticleId0",
>           "user_id": "testUserId0",
>           "title": "Authentication System Part 1",
>           "created_at": "2019-05-02T04:32:09.537Z",
>           "last_modified_at": "2019-05-02T04:32:09.537Z",
>           "author": {
>             "userName": "Jon",
>           },
>         },
> 
>         ...
>
>       ]
>     }
>   }
> }
> ```
> 
> And the get articles by id one:
> 
> ```json
> mountingPoint.getArticlesById = (succeeded, article_id) => {
>   if (succeeded) {
>     console.log(article_id);
>     let fakeAllArticles = [
>       {
>         "article_id": "testArticleId0",
>         "user_id": "testUserId0",
>         "title": "Authentication System Part 1",
>         "created_at": "2019-05-02T04:32:09.537Z",
>         "last_modified_at": "2019-05-02T04:32:09.537Z",
>         "author": {
>           "userName": "Jon",
>         },
>         "content": fakeArticle0,
>       },
>       
>       ...
>       
>     ];
> 
>     return {
>       "success": true,
>       "article": fakeAllArticles.filter(article => article.article_id === article_id)[0]
>     }
>   } else {
>     ...
>     }
>   }
> };
> ```
> 
> And now, our web can fetch and show these fake data properly. (Quite ugly, although)

2. Enable frontend authentication control

> In this part, we will finish the authentication control functions illustrated in our goals. In specific, we need to let users to see their articles in their personal page and let them to CURD their articles.
> 
> First, we need to make a new API to specially obtain articles published by specific user. It is be very similar to ```getArticlesById``` API, so here I will not repeat this part.
> 
> Then, I realized that in my orginal Vuex user login status, I only recorded the user name of logged in user. However, it would be much better(And also more reliable) to use user id for distinguishing different users. So here I need to make some modifications on my Vuex. Meanwhile, although using user id is a better choise, we still need some other user infomation such as user name to be displayed on our page. To avoid requesting user data again and again, here I decide to store all available except user sensitive data (Password, for example) in Vuex to improve performance.
> 
> And I also added some data verification in Vuex so that if deverlopers give wrong data to Vuex, they can be warned in time.
> 
> Now, my Vuex looks like this:
> 
> state.js
> 
> ```js
> export default {
>   loggedIn: false,
>   userData: {},
> }
> ```
> 
> mutations.js
>
> ```js
> export default {
>   LOGGING_IN(state, userData) {
>     state.loggedIn = true;
>     state.userData = userData;
>   },
> 
>   LOGGING_OUT(state) {
>     state.loggedIn = false;
>     state.userData = {};
>   },
> }
> ```
> 
> actions.js
>
> ```js
> export default {
>   loggingIn({ commit }, userData) {
>     commit('LOGGING_IN', userData);
>   },
> 
>   loggingOut({ commit }) {
>     commit('LOGGING_OUT');
>   },
> }
> 
> ```
> 
> getters.js
> 
> ```js
> export default {
>   checkLogin: function (state) {
>     return state.loggedIn;
>   },
>   getUserData: function (state) {
>     return state.userData;
>   },
> }
> ```
> 
> By the way, I think it is worth mentioning that, during modifying my Vuex componets, I think the name for 'state' is not proper. Therefore, I changed it into 'states', which cause a problem that the store componets cannot recognize it. So I changed it back. I spent about half an hour to locate the problem! So don't renaming anything cause that might cause problems!
> 
> An it is also necessary to mention that I noticed that our backend now returnning user's all infomation back to the client including user's sensitive data such as password. Avoid doing that.
> 
> Now, it's the time to build our user info page. Since we're now focusing on the function of the page, I'll not do any UI works here. I'll only set user info page to show user's articles.
> 
> Since here, listing all posts of a user are quite similar to the listing all posts in our Post page, I think it is good to separate it out from ```PagePost.vue``` and build the grabbing and listing article function into a component.
> 
> So I created a component called ```PostArticles.vue``` and put the following code inside:
> 
> ```html
> <template>
>   <div class="postArticles">
>     <ol>
>       <li class="onePost" v-for="articlePost in articlePosts" v-bind:key="articlePost.article_id">
>         <router-link :to="{name: 'pagearticle', params:{articleId: articlePost.article_id}}">
>           {{articlePost.title}}
>         </router-link>
>       </li>
>     </ol>
>   </div>
> </template>
> 
> <script>
> export default {
>   name: 'postarticles',
> 
>   props: {
>     articleFieldSelector: {
>       type: String,
>       required: true,
>       validator: function (value) {
>         return [
>           'all',
>           'loggedinuser',
>         ].indexOf(value.toLowerCase()) !== -1;
>       }
>     },
>     userId: {
>       type: String,
>       required: false,
>     }
>   },
> 
>   computed: {
> 
>   },
> 
>   data() {
>     return {
>       articlePosts: [],
>       RetrieveMode: undefined,
>     }
>   },
> 
>   mounted() {
>     switch(this.articleFieldSelector.toLowerCase()) {
>       case 'all':
>         this.RetrieveMode = this.$options.methods.getAllArticles;
>         break;
>       case 'loggedinuser':
>         this.RetrieveMode = this.$options.methods.getLoggedInUsersArticles;
>         break;
>       default:
>         console.log('No effective article field selector defined!');
>         console.log('Set mode to default');
>         this.RetrieveMode = this.$options.methods.getAllArticles;
>       break;
>     };
> 
>     this.RetrieveMode();
>   },
> 
>   methods: {
>     getAllArticles() {
>       this.articlePosts = this.$DataProvider.getAllArticlesPosts(true).articles;
>     },
> 
>     getLoggedInUsersArticles() {
>       console.log(this.$store.getters.getUserData.uuid)
>       this.articlePosts = this.$DataProvider.getArticlesOfUser(true, this.userId).articles;
>     }
>   },
> }
> </script>
> 
> <style scoped>
> 
> </style>
> ```
> 
> So with this PostArticles component, I can now easily control what articles to be listed and shown with proper hyperlinks to them. For example, my Post page now is:
> 
> ```html
> <template>
>   <div class="pagePost">
>     <PostArticles :articleFieldSelector="'ALL'"/>
>   </div>
> </template>
> ```
> 
> And the component ```PostArticles``` will accept a selector and list article links according to that.
> 
> Then, I realized that because I have used userName for distinguishing users, rather than the uuid used here, it causes many problems when sending and changing these data inside my frontend. (Some places using userName, while some others using userId, this makes we have to keep getting userName from userId and getting userId from userName).
> 
> This is quite bad implementation. Thus I decide to take some time to change all places using uuid for distinguishing users.
> 
> After that, now we can finally work on the CURD part. First of all, we will work on 'create'  part.
> 
> Since we have added mavonEditor yesterday, we can now just simply use it. First, create a new page for the editor called ```PageEditor.vue``` in our views folder. Then, set our router pointing to the new page. Meanwhile, the path needs to contain the user id and the new article title, so it will be like this:
>
> ```js
> {
>   path: 'editor/:userId/:articleTitle',
>   name: 'pageeditor',
>   component: () => import('@/views/PageEditor.vue'),
>   meta: {
>     requireAuthentication: true,
>   }
> }
> ```
> 
> Then import the mavonEditor into editor page. And don't forget to write saving method for the editor. Here I used a fake create API for our article creation. Once this API receives the data, it will print the data in the console. So my data provider (the fake creation API) looks like this:
> 
> ```js
> mountingPoint.createArticle = (article_content) => {
>   console.log(article_content);
> }
> ```
> 
> And my editor page looks like this:
> 
> ```js
> <template>
>   <div class="pageEditor">
>     <mavon-editor v-model="articleContent" @save="saveArticle"/>
>   </div>
> </template>
> 
> <script>
> import { mavonEditor } from 'mavon-editor';
> import 'mavon-editor/dist/css/index.css';
> 
> export default {
>   name: 'pageeditor',
> 
>   data() {
>     return {
>       articleContent: '',
>       currentUser: this.$route.params.userId.toString(),
>       currentArticleTitle: this.$route.params.articleTitle,
>     }
>   },
> 
>   components: {
>     mavonEditor
>   },
> 
>   methods: {
>     saveArticle() {
>       this.$DataProvider.createArticle(this.articleContent);
>     }
>   }
> }
> </script>
> 
> <style scoped>
> 
> </style>
> ```
> 
> it now simply receiving the content and send it to the backend.
> 
> Now a simple version of creation has been finished. The next step is to make an 'Update' function
> 
> To make the 'Update' function, first of all, we need to make the list of our articles become selectable. They need to be selected, then be updated. Since our list is rendered by ```PostArticles``` component, we need to change this component to make the list selectable.
> 
> Here I choose to add another props for this component called 'selectBox', if it is true, this component will add a checkbox behind each article title so that the user can select it. If it is false, this component will only render article titles. Since this option will only be used in very limited situations, so we need to give a default value to this props so that we don't need to change our old code. I set it in this way:
> 
> ```js 
> selectBox: {
>   type: Boolean,
>   required: false,
>   default: true,
> },
> ```
> 
> And in my template, it is changed to:
> 
> ```html
> <ol>
>   <li class="onePost" v-for="articlePost in articlePosts" v-bind:key="articlePost.article_id">
>     <router-link :to="{name: 'pagearticle', params:{articleId: articlePost.article_id}}">
>       {{articlePost.title}}
>     </router-link>
>     <input v-if="selectBox" type="checkbox" v-bind:id="articlePost.article_id">
>   </li>
> </ol>
> ```
> 
> Now, it will not throw any error when 'selectBox' is not set and will act as default. If 'selectBox' is set to ```true```, it will render a checkbox behind each article title.
> 
> It is important to mention the way to use props in template, it is 
> 
> ```html
> <input v-if="selectBox" type="checkbox" v-bind:id="articlePost.article_id">
> ```
> 
> Not
> 
> ```html
> <input v-if="this.selectBox" type="checkbox" v-bind:id="articlePost.article_id">
> ```
> 
> *DO NOT* use ```this``` in template part. But *DO* use ```this``` in script part when you need to use props.
> 
> Of course, don't forget to emit our data out for other components using:
>
> ```js
> watch: {
>   selectedArticles: function (val) {
>     this.$emit('sendingSelectedArticles', this.selectedArticles);
>   }
> },
> ```
> 
> Then, set an event handler in UserInfo page and make some proper changes to ensure our opertaions are making sense. I'll not repeate myself too much in this part. If you need help you can go to check my code.
> 
> After this, now I have finished selection part. Now working on the 'Update' function. Here I'll still use a fake API for updating opertaion. Again, this API is just displaying what has been delivered to the backend.
> 
> When building 'Update' function for my articles, I noticed that I have to resolve the value sending issue. In more specific, when the user chooses to edit any article, we need to send the article itself to the editor. So when the user is redirected to that page, the user can continue editing on that page.
> 
> However, sending the article to that page is a big issue for us. First, it is not a global variable, so Vuex is not usable. Then, the two pages, editor page and user info page, are not related. There is no way to use ```emit``` or ```props``` to transfer data.
> 
> So, here I used router for transferring data. When I redirecting the user, I used:
> 
> ```js 
> let userId = this.$store.getters.getUserData.uuid;
> let article = this.$DataProvider.getArticleById(true, this.selectedArticles[0]).article;
> this.$router.push({name: 'pageeditor', params: {userId: userId, articleTitle: article.title, article: article}});
> ```
> 
> So, in editor page, I can use
> 
> ```js
> if (this.$route.params.article) {
>   this.articleContent = this.$route.params.article.content;
> }
> ```
> 
> To check whether the article is sent or not, and access the article content when it is sent.
> 
> However, it is also worth mentioning that with this solution, the user cannot refresh page. If the user refreshes the page, all article info will be lost.
> 
> 
> 

---

### Todos

1. Change backend response on logging in. DO NOT put user's sensitive data in responses such as user's password.